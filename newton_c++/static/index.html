<!DOCTYPE html>

<head>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
<script src="math.js" type="text/javascript"></script>
</head>

<center>
	<div id="SettingsHolder">
		<h2>Function</h2>
		<center>
			<input type='text' class='setting' placeholder='input function here' id="function_holder" onchange="funcc = this.value"></input>
		</center>
		<h2>Maximun Iteration Count</h2>
		<center>
			<input type='text' class='setting' placeholder='Maximum Iteration Count here' id="iteration_holder" onchange="MaxIterationCount = this.value; console.log('MaxIterationCount changed to : ' + MaxIterationCount)"></input>
		</center>		
		<h2>Vertecies per dir.</h2>
		<center>
		<input type='text' class='setting' placeholder='1000' id="vertex_holder" onchange="ammounOfVerteciesX = this.value; console.log('ammounOfVerteciesX changed to : ' + ammounOfVerteciesX); ammounOfVerteciesY = this.value; setVertecies();"></input>
		</center>	
	</div>
	<button id="button" onclick="calculate();">
		Calculate
	</button>
</center>
<center>
	<div id="cnavasHolder">
		<canvas id="canvas-view">
		  Your browser does not seem to support HTML canvas.
		</canvas>
	</div>
</center>
<div id="coordinates">
Re: 100.3  Im: 5.1
</div>
<div class="coverUpBar" style="top:0%; height:10%; width:100%;"></div>
<div class="coverUpBar" style="left:0%; height:100%; width:5%;"></div>
<div class="coverUpBar" style="bottom:0%; height:10%; width:100%;"></div>






<style>

body {
margin:0;
padding:0;
background-color:white;
font-family: 'Roboto', sans-serif;
font-size: 1vw;
background-color:rgba(0,0,0,0.7);
overflow:hidden;
}

h2{
margin-bottom:1vh;
}


#cnavasHolder{
width:70%;
height:80%;
position:absolute;
top:10%;
left:5%;
background-color:rgba(230,230,230,0.1);
}
canvas {
  position:absolute;
  display: block;
  width: 100%;
  height: 100%;
  margin: auto;
  top:0;
  left:0;
  padding: 0;
  border: none;
  background-color: white;
  z-index:0;
}
#SettingsHolder{
width:25%;
height:80%;
position:absolute;
top:10%;
right:0%;
background-color:gray;
z-index:3;
}

button{
position:absolute;
right:2.5%;
bottom:15%;
width:20%;
background-color: #e7e7e7;
color: black;
padding: 15px 32px;
text-align: center;
text-decoration: none;
display: inline-block;
box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
transition-duration: 0.4s;
cursor:pointer;
border:0;
border-radius:10px;
font-size: 3vw;
z-index:3;
}
button:hover {
background-color: navy;
color: white;
}


input[type=text] {
  padding:10px;
  border:0;
  box-shadow:0 0 15px 4px rgba(0,0,0,0.06);
  border-radius:30px;
  width:80%;
  min-width:30%;
  text-align: center;
  margin-top:1vh;
  margin-bottom:3vh;
}

.setting{
width:80%;
}

#coordinates{
position:absolute;
background-color:rgba(10,10,10,0.3);
color:white;
height:auto;
width:auto;
bottom:10%;
right:25%;
}

.coverUpBar{
position:absolute;
z-index:3;
background-color:rgba(109,109,109,1);
}

</style>




<script>



// CANVAS listens to "zoom" EVENT here
function zoom(event){
	zoom_start(event.deltaY); // aactually draggs around the CANVAS
	calculate(); // will calculate a Image
}
const el = document.getElementById("canvas-view");
el.onwheel = zoom;


// Object holds mouse Position
let mousePos = { x: undefined, y: undefined };
// these variables hold the canvas to top/bottom/right/left DISTANCE and the canvas DIMENSIONS
var topp;
var leftt;
var widthh;
var heightt;
function updatePosition(){ // updates the position variables of the canvas
	topp = document.getElementById("canvas-view").getBoundingClientRect().top - document.body.getBoundingClientRect().top; // DISTANCE: CANVAS to WINDOW.top
	leftt = document.getElementById("canvas-view").getBoundingClientRect().left - document.body.getBoundingClientRect().left; // DISTANCE: CANVAS to WINDOW.left
	widthh = document.getElementById("canvas-view").getBoundingClientRect().right - document.getElementById("canvas-view").getBoundingClientRect().left;// WIDTH: CANVAS
	heightt = document.getElementById("canvas-view").getBoundingClientRect().bottom - document.getElementById("canvas-view").getBoundingClientRect().top;  // HEIGHT: CANVAS
}
updatePosition();
// these are good for DRAGGING OPERATION and hold distances to where CANVAS is and should be
var topp2 = 0;
var leftt2 = 0;

// CANVAS listens to "move" EVENT here and finds out its coordinates relative to the CANVAS [so (0.5, 1) means 50% to the right and 100% to the bottom]
function mouseMove(event){
mousePos = { x: event.clientX, y: event.clientY };
document.getElementById("coordinates").innerHTML = "Re: " + (mousePos.x-leftt)/widthh + "   Im: " + (mousePos.y-topp)/heightt;
	if(mouseDown == true){	// has to do with dragging the CANVAS around
		drag_start(); // aactually draggs around the CANVAS
		updatePosition(); // only needs to happen after dragging not after zooming :)
	}
}
el.onmousemove = mouseMove;

//onMouseOUT the coordinates dissapear
function mout(){document.getElementById("coordinates").innerHTML = "";}
el.onmouseout = mout;

// for dragging the CANVASvar 
speedfactor = 1;// determines speed with witch the CANVAS follows the cursor.
var toppdiff = 0; // will hold the Position difference (that is to be added)
var leftdiff = 0;
let mouseDown = false; // checks if mouse is down
var initial_mousepos_x = 0; // mousepos before dragging
var initial_mousepos_y = 0;

// eventlisteners for the dragging OPERATION
el.addEventListener('mousedown', (event) => {
	mouseDown = true;
	initial_mousepos_x = mousePos.x;
	initial_mousepos_y = mousePos.y;
});
window.addEventListener('mouseup', (event) => {
  mouseDown = false;
  	topp2 += toppdiff;
	leftt2 += leftdiff;
	// uppdate global coordinates object
	coordinates.pixels(); // important beacues we dont want to mix up units now when we add stuff
	coordinates.y += toppdiff;
	coordinates.x += leftdiff;
	coordinates.uppdate();
	console.log(coordinates);
	toppdiff = 0;
	leftdiff = 0;
	calculate(); // will calculate a Image after the dragging process finished
});
// actually moving the CANVAS
function drag_start(){
	let diff_x = initial_mousepos_x-mousePos.x;
	let diff_y = initial_mousepos_y-mousePos.y;
	let newtop = (topp2 + (-diff_y/speedfactor)) + "px";
	let newlwft = (leftt2 + (-diff_x/speedfactor)) + "px";
	el.style.top = newtop;
	el.style.left = newlwft;
	toppdiff = (-diff_y/speedfactor);
	leftdiff = (-diff_x/speedfactor);
}

// these are used in zoom_start(...) and provide the theoretical distance between canvas and left/top border of screen
var canvas_HolderOffset_x = document.getElementById("cnavasHolder").getBoundingClientRect().left - document.body.getBoundingClientRect().left;
var canvas_HolderOffset_y = document.getElementById("cnavasHolder").getBoundingClientRect().top - document.body.getBoundingClientRect().top;


//now zooming the current image is handeled
function zoom_start(zooom){ // will zoom in on the picture that is currently there
	var zooom = (Math.atan(-zooom/100)+Math.PI/2)*(2/Math.PI); // this is necessary becaus zoom event returns number between [-infty, infty], and we need a factor.
	// actually zooms in on the picture [deviding by 100 to get realistic zoom speed]
	var topp3 = topp - canvas_HolderOffset_y;
	var leftt3 = leftt - canvas_HolderOffset_x;
	// x:
	el.style.width = widthh*(zooom) + "px"; 
	widthh = widthh*(zooom);
	// y:
	el.style.height = heightt*(zooom) + "px"; 
	heightt = heightt*(zooom);
	// x:
	var pointer_x = (mousePos.x - leftt3 - canvas_HolderOffset_x); // tihs is the CANVAS-MOUSE-DIFFERENCE plus the theoretical CANVAS.left
	el.style.left = (leftt3 - (pointer_x*(zooom-1))) + "px";
	leftt = leftt3 - (pointer_x*(zooom-1)) + canvas_HolderOffset_x; // uppdating global leftt var after resize
	leftt2 += - (pointer_x*(zooom-1)); // uppdating global leftt2 var after resize
	// y:
	var pointer_y = (mousePos.y - topp3 - canvas_HolderOffset_y); // tihs is the CANVAS-MOUSE-DIFFERENCE plus the theoretical CANVAS.left
	el.style.top = (topp3 - (pointer_y*(zooom-1))) + "px";
	topp = topp3 - (pointer_y*(zooom-1)) + canvas_HolderOffset_y;// uüüdating global topp var after resize
	topp2 += - (pointer_y*(zooom-1)); // uppdating global topp2 var after resize
	
	// update global coordinates object (containing zoom and translation)
	coordinates.pixels(); // important beacues we dont want to mix up units now when we add stuff
	coordinates.x += - (pointer_x*(zooom-1));
	coordinates.y += - (pointer_y*(zooom-1));
	coordinates.zoom *= zooom;
	coordinates.uppdate();
}

// GUI basically ends here and the calculation with WEB GL beginns


// coordinates holds all relevant information of the current theoretial viewport
class canvas_coordinates{	

	constructor() {
		this.x = 0;	// holds the translation Vector that points from the thoretial Right-top-Origin to the canvas-Right-Top-Origin
		this.y = 0;
		this.zoom = 1; // holds the zoom factor (relative to initial CANVAS-viewport)
		this.unit = true; // holds info about wether current numbers are in pixels or in C-coords
		this.factor = widthh/20; // holds the factor to convert from pixel to C-coordinates (widthh is CANVAS width and 20 is Real axis scale shown in beginning)
		this.yLimits = [(heightt/2)/this.factor, -(heightt/2)/this.factor]; // holds the limits of the view-port in C-coords only
		this.xLimits = [-10,10];
		this.ratio = heightt/widthh;
		this.pixelMatrix = [document.getElementById("cnavasHolder").getBoundingClientRect().right - document.getElementById("cnavasHolder").getBoundingClientRect().left,document.getElementById("cnavasHolder").getBoundingClientRect().bottom - document.getElementById("cnavasHolder").getBoundingClientRect().top] //vertical x horizontal pixel count, NOT uppdated ever...
	}
	
	pixels(){ // converts from C-field coordinates to pixel coordinates
		if(this.unit){}
		else{
			this.x = this.x*this.factor;
			this.y = this.y*this.factor;
			this.unit = false;
		}
	}
	coords(){ // converts from pixels to C-vector entries
		if(this.unit == false){}
		else{
			this.x = this.x/this.factor;
			this.y = this.y/this.factor;
			this.unit = true;
		}
	}
	
	uppdate(){ // will refresh all the properties/ recalculate with new zoom,x,y values
		if(this.unit){
			updatePosition();// just to update topp,leftt,widthh and heightt of CANVAS
			//TO BE CORECTED
			this.factor = widthh/20; 
			this.ratio = heightt/widthh;
			this.yLimits = [(this.y)/this.factor + 10*this.ratio,(this.pixelMatrix[1]-this.y)/this.factor - 10*this.ratio];
			this.xLimits = [(this.x)/this.factor + 10,(this.pixelMatrix[0]-this.x)/this.factor - 10];
			this.pixelMatrix = [document.getElementById("cnavasHolder").getBoundingClientRect().right - document.getElementById("cnavasHolder").getBoundingClientRect().left,document.getElementById("cnavasHolder").getBoundingClientRect().bottom - document.getElementById("cnavasHolder").getBoundingClientRect().top] //vertical x horizontal pixel count, NOT uppdated ever...
		}
		else{
			throw new Error('uppdating is noly supportet in pixel units');
		}
	}
	
}
const coordinates = new canvas_coordinates; // coordinates object holds all relevant info for viewport


// HERE calculations beginn
var funcc = document.getElementById("function_holder").value; // holds the information for the function that is to be plotted, changes ONCHANGE in inline JS
var MaxIterationCount = document.getElementById("iteration_holder").value; // holds the maximun iterations, changes ONCHANGE in inline JS
function calculate(){
	calculatePython(funcc);
	//console.log(calculatePreset(funcc));// can only calculate functions of type x^n-1
// the following functions either call other programms or perform natively to produce Image
//...
}

function calculatePreset(string){ // uses binomial theorem to calculate re and Im of f/f' of x^n-1
	var n = string.substring(string.indexOf('^') + 1, string.indexOf('-')); // gets the power
		// extracts real and im part
		var real_part = "";
		var im_part = "";
		var u_a	= "";
		var u_b = "";
		var v_a = "";
		var v_b = "";
		for (var k = 0; k < n; k++){
			if(k%4 == 0){ // i^4 = 1
				real_part += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					u_a += String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					u_b += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
			else if(k%3 == 0){ // i^3 = -i
				im_part += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					v_a += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					v_b += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
			else if(k%2 == 0){ // i^2 = -1
				real_part += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					u_a += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					u_b += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
			else{ // i^1 = i
				im_part += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					v_a += String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					v_b += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
	
	}
	var u = real_part;
	var v = im_part;
	var final_real = "(1.0/(pow(" + u_a + ",2.0) + pow(" + v_a + ",2.0)))*(" + u + "*" + u_a + " + " + v + "*" + v_a + ")";
	var final_im = "(1.0/(pow(" + u_a + ",2.0) + pow(" + v_a + ",2.0)))*(" + u + "*" + u_b + " + " + v + "*" + v_b + ")";
	
	// for TESTING purposes changed
	return [
	final_real,
	final_im
	];// reference wikipedia : https://de.wikipedia.org/wiki/Newtonverfahren
}


function calculatePython(string){ // uses sympy server to calculate what we need (f/f')
	// THESE hold the final RETURN values and are changed after POST
	var retter1 = 0;
	var retter2 = 0;

	// Javascript program to find index of closing
  // bracket for given opening bracket.
  class Stack {
    constructor() {
      this.items = [];
    }
 
    // add element to the stack
    push(element) {
      return this.items.push(element);
    }
 
    // remove element from the stack
    pop() {
      if (this.items.length > 0) {
        return this.items.pop();
      }
    }
 
    // view the last element
    top() {
      return this.items[this.items.length - 1];
    }
 
    // check if the stack is empty
    isEmpty() {
      return this.items.length == 0;
    }
 
    // the size of the stack
    size() {
      return this.items.length;
    }
 
    // empty the stack
    clear() {
      this.items = [];
    }
  }
  let st = new Stack();
 
  // Function to find index of closing
  // bracket for given opening bracket.
  function right(expression, index) {
    var i;
 
    // If index given is invalid and is
    // not an opening bracket.
    if (expression[index] != "(") {
	  // if the character is a number just look for next blank space
	  var i = index;
	  while(!isNaN(parseInt(expression[i])) || expression[i] == "." || expression[i].match(/[a-z]/i)){ // floatingpoint and numbers are viewed as he same
		i++;
		//console.log("in while : " + expression[i]);
	  }
	  //console.log(expression.slice(index, i) + " : is Number from " + index +  " till " + i + " index of " + expression);
	  return i;
    }
 
    // Stack to store opening brackets.
    let st = new Stack();
    //stack <int> st;
 
    // Traverse through string starting from
    // given index.
    for (i = index; i < expression.length; i++) {
      // If current character is an
      // opening bracket push it in stack.
      if (expression[i] == "(") st.push(expression[i]);
      // If current character is a closing
      // bracket, pop from stack. If stack
      // is empty, then this closing
      // bracket is required bracket.
      else if (expression[i] == ")") {
        st.pop();
        if (st.isEmpty()) {
          //console.log(expression + ", " + index + ": " + i);
          return i+1;
        }
      }
    }
 
    // If no matching closing bracket
    // is found.
    return 404
  }
  
function left(expression, index) {


    var i;
 
    // If index given is invalid and is
    // not an opening bracket.
    if (expression[index] != ")") {
	  // if the character is a number just look for next blank space
	  var i = index;
	  //console.log(expression[i])
	  while(!isNaN(parseInt(expression[i])) || expression[i] == "." || expression[i].match(/[a-z]/i)){ // floatingpoint and numbers are viewed as he same
		i--;
		//console.log("in while : " + expression[i]);
	  }
	  //console.log(expression.slice(index, i) + " : is Number from " + index +  " till " + i + " index of " + expression);
	  return i + 1;
    }
 
    // Stack to store opening brackets.
    let st = new Stack();
    //stack <int> st;
 
    // Traverse through string starting from
    // given index.
	//console.log("log of LEFT " + expression[index]);
    for (i = 0; i < expression.length; i++) {
      // If current character is an
      // opening bracket push it in stack.
      //console.log("log of LEFT in FOR " + expression[index - i]);
	  if (expression[index - i] == ")") st.push(expression[index - i]);
      // If current character is a closing
      // bracket, pop from stack. If stack
      // is empty, then this closing
      // bracket is required bracket.
      else if (expression[index - i] == "(") {
        st.pop();
        if (st.isEmpty()) {
          //console.log(expression + ", " + index + ": " + i);
		  return index - i;
        }
      }
    }
 
    // If no matching closing bracket
    // is found.
    return 404
  }
  
  
  
  function PowerSyntaxConverter(str){ // will convert from ** PowerSyntax to pow(...) PowerSyntax
	var lenn = JSON.parse(JSON.stringify(str)).split("**") // 3**2 -> [3,2] JUST for for loop iteration ammount
	//console.log(lenn)
	for(var i = 0; i < lenn.length - 1; i++){
		//console.log("BEFORE" + str);
		// search right with right(), wich returns index of the end of the expression on the right:
		var rightTerm = str.slice(str.indexOf("**") + 2,right(str, str.indexOf("**") + 2));
		//console.log("right " + rightTerm);
		// search left with left(), wich returns index of the end of the expression on the left:
		var leftTerm = str.slice(left(str, str.indexOf("**") - 1), str.indexOf("**"))
		//console.log("left " + leftTerm);
		// now replace [leftTerm**rightTerm] width [pow(leftTerm,rightTerm)]
		str = str.replace(leftTerm + "**" + rightTerm , "pow(" + leftTerm + "," + rightTerm + ")");
		//console.log(str);
	}
	return str
}
  
  	function postdata(daTa){
	try{
		postData1("http://localhost:5000/", {"info" : JSON.stringify(daTa)}).then((data) => {
				
				function formatToGLSLfloat(sstr){
					// formating to GLSL flaots here
					const regexp = /[\d|.|\+]+/g;
					var str = sstr;
					var match;
					var tempstr = str.split("");
					//console.log(tempstr);
					var matcher = 0;
					while ((match = regexp.exec(str)) !== null) {
					  //console.log(
						//`Found ${match[0]} start=${match.index} end=${regexp.lastIndex}.`,
					  //);
					  if(match[0].includes(".") || match[0].includes("+")){}//do nothing
					  else{
						tempstr.splice(match.index - matcher, match[0].length, match[0].split("").concat(".0".split("")).join(""));
						matcher += match[0].length-1;
					  }
					  //console.log(tempstr)
					}
					//console.log(tempstr)
					return tempstr.join("")
				}
				
				retter1 = formatToGLSLfloat(PowerSyntaxConverter(data.info[0])).replaceAll("+.0", "+");
				retter2 = formatToGLSLfloat(PowerSyntaxConverter(data.info[1])).replaceAll("+.0", "+");
				runGL(retter1, retter2)
			});
		}
		catch(err){
			console.log("error while fetching DATA");
		}
	}
	postdata(funcc); // POST some DATA here to PYTHON SERVER
}




// Example POST method implementation:
async function postData1(url = "", data = {}) {
  // Default options are marked with *
  const response = await fetch(url, {
    method: "POST", // *GET, POST, PUT, DELETE, etc.
    mode: "cors", // no-cors, *cors, same-origin
    cache: "no-cache", // *default, no-cache, reload, force-cache, only-if-cached
    credentials: "same-origin", // include, *same-origin, omit
    headers: {
      "Content-Type": "application/json",
      // 'Content-Type': 'application/x-www-form-urlencoded',
    },
    redirect: "follow", // manual, *follow, error
    referrerPolicy: "no-referrer", // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    body: JSON.stringify(data), // body data type must match "Content-Type" header
  });
  return response.json(); // parses JSON response into native JavaScript objects
}





// OPEN GL HERE
function runGL(retter1, retter2){
var Schranke = 0.0000001 // einfach setzen (empirische Entscheidung)
// this holds the NEWTON Algorithm
var functionString = [
"float temp_real = position[0]*float(" + 1 + ");",
"float temp_im = position[1];",
"int counter = 1;",
"int Booler = 1;",
"for (int j = 0; j < " + MaxIterationCount + "; j += 1){",
	"if(Booler == 1 && pow(pow("  + retter1.replaceAll('b', 'temp_im').replaceAll('a', 'temp_real') + ",2.0) + pow(" + retter2.replaceAll('b', 'temp_im').replaceAll('a', 'temp_real') + ",2.0),0.5) < " + Schranke + "){",
		"counter = j;",
		"Booler = 2;",
	"}",
	"temp_real = temp_real -" + retter1.replaceAll('b', 'temp_im').replaceAll('a', 'temp_real') +  ";",
	"temp_im = temp_im - " + retter2.replaceAll('b', 'temp_im').replaceAll('a', 'temp_real') + ";",
"}",
"vColor = vec3(float(counter)/10.0,float(counter)/10.0,float(counter)/10.0);"
].join("\n")

//console.log(functionString);

//GET canvas elem
const canvas = el;
const gl = canvas.getContext('webgl');

// cheacks if browser supports WEBGL
if (!gl) {
    throw new Error('WEBGL is not supported on your BROWSER');
}

// clears the background color
gl.clearColor(0,0,1,1);
gl.clear(gl.COLOR_BUFFER_BIT);


const positionBuffer = gl.createBuffer(); // create BUFFER for position verteces
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.DYNAMIC_DRAW);



const vertexShader = gl.createShader(gl.VERTEX_SHADER); // create actual shader
gl.shaderSource(vertexShader, [
"precision highp float;",
"attribute vec3 position;",
"varying vec3 vColor;",
"void main() {",// position vertecies get placed
    "gl_Position = vec4(position, 1);",// for loop has to take place here NEWTON INTEROPLATION
	functionString,
	"}"
].join("\n"));
gl.compileShader(vertexShader);//compile vertexShader

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);// create fragment shader
gl.shaderSource(fragmentShader, `
precision mediump float;

varying vec3 vColor; // will pass information from position to color main-function

void main() { // color is beeing assigned (by position reference)
    gl_FragColor = vec4(vColor, 1);
}
`);
gl.compileShader(fragmentShader); // compile fragmentShader


const program = gl.createProgram();// creating program for shaders here
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);

gl.linkProgram(program);// linking

const positionLocation = gl.getAttribLocation(program, `position`);// attribute assigning ; position
gl.enableVertexAttribArray(positionLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);


gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, vertexData.length/3); // actually drawing here
}
























//just for triggering the button on enter
// Get the input field
var input = document.getElementById("button");

// Execute a function when the user presses a key on the keyboard
input.addEventListener("keypress", function(event) {
  // If the user presses the "Enter" key on the keyboard
  if (event.key === "Enter") {
    // Cancel the default action, if needed
    event.preventDefault();
    // Trigger the button element with a click
    document.getElementById("button").click();
  }
}); 


function binomial(n, k) { // just binomial coefficient calc
     if ((typeof n !== 'number') || (typeof k !== 'number')){
		n = parseInt(n);
		k = parseInt(k);
	 }
    var coeff = 1;
    for (var x = n-k+1; x <= n; x++) coeff *= x;
    for (x = 1; x <= k; x++) coeff /= x;
    return Math.round(coeff);
}


const vertexData = [ // JUST DATA (many more vertecies are needed to ensure clear image)

];
// load vertecies
var ammounOfVerteciesX = document.getElementById("vertex_holder").value;
var ammounOfVerteciesY = document.getElementById("vertex_holder").value;
function setVertecies(){
	for(jk = 0; jk < ammounOfVerteciesY; jk++){
		for(kj = 0; kj < ammounOfVerteciesX; kj++){
			vertexData.push(-1 + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY) + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY)*jk,0);
			vertexData.push(-1 + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY) + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY)*jk,0);
		}
	}
}
setVertecies();
</script>