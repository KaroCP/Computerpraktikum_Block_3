<!DOCTYPE html>

<head>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
</head>

<center>
	<div id="SettingsHolder">
		<h2>Function</h2>
		<center>
			<input type='text' class='setting' placeholder='input function here' id="function_holder" onchange="funcc = this.value"></input>
		</center>
		<h2>Maximun Iteration Count</h2>
		<center>
			<input type='text' class='setting' placeholder='Maximum Iteration Count here' id="iteration_holder" onchange="MaxIterationCount = this.value"></input>
		</center>		
	</div>
	<button id="button" onclick="calculate();">
		Calculate
	</button>
</center>
<center>
	<div id="cnavasHolder">
		<canvas id="canvas-view">
		  Your browser does not seem to support HTML canvas.
		</canvas>
	</div>
</center>
<div id="coordinates">
Re: 100.3  Im: 5.1
</div>
<div class="coverUpBar" style="top:0%; height:10%; width:100%;"></div>
<div class="coverUpBar" style="left:0%; height:100%; width:5%;"></div>
<div class="coverUpBar" style="bottom:0%; height:10%; width:100%;"></div>






<style>

body {
margin:0;
padding:0;
background-color:white;
font-family: 'Roboto', sans-serif;
font-size: 1vw;
background-color:rgba(0,0,0,0.7);
overflow:hidden;
}

h2{
margin-bottom:1vh;
}


#cnavasHolder{
width:70%;
height:80%;
position:absolute;
top:10%;
left:5%;
background-color:rgba(230,230,230,0.1);
}
canvas {
  position:absolute;
  display: block;
  width: 100%;
  height: 100%;
  margin: auto;
  top:0;
  left:0;
  padding: 0;
  border: none;
  background-color: white;
  z-index:0;
}
#SettingsHolder{
width:25%;
height:80%;
position:absolute;
top:10%;
right:0%;
background-color:gray;
z-index:3;
}

button{
position:absolute;
right:2.5%;
bottom:15%;
width:20%;
background-color: #e7e7e7;
color: black;
padding: 15px 32px;
text-align: center;
text-decoration: none;
display: inline-block;
box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
transition-duration: 0.4s;
cursor:pointer;
border:0;
border-radius:10px;
font-size: 3vw;
z-index:3;
}
button:hover {
background-color: navy;
color: white;
}


input[type=text] {
  padding:10px;
  border:0;
  box-shadow:0 0 15px 4px rgba(0,0,0,0.06);
  border-radius:30px;
  width:80%;
  min-width:30%;
  text-align: center;
  margin-top:1vh;
  margin-bottom:3vh;
}

.setting{
width:80%;
}

#coordinates{
position:absolute;
background-color:rgba(10,10,10,0.3);
color:white;
height:auto;
width:auto;
bottom:10%;
right:25%;
}

.coverUpBar{
position:absolute;
z-index:3;
background-color:rgba(109,109,109,1);
}

</style>




<script>
// CANVAS listens to "zoom" EVENT here
function zoom(event){
	zoom_start(event.deltaY); // aactually draggs around the CANVAS
	calculate(); // will calculate a Image
}
const el = document.getElementById("canvas-view");
el.onwheel = zoom;


// Object holds mouse Position
let mousePos = { x: undefined, y: undefined };
// these variables hold the canvas to top/bottom/right/left DISTANCE and the canvas DIMENSIONS
var topp;
var leftt;
var widthh;
var heightt;
function updatePosition(){ // updates the position variables of the canvas
	topp = document.getElementById("canvas-view").getBoundingClientRect().top - document.body.getBoundingClientRect().top; // DISTANCE: CANVAS to WINDOW.top
	leftt = document.getElementById("canvas-view").getBoundingClientRect().left - document.body.getBoundingClientRect().left; // DISTANCE: CANVAS to WINDOW.left
	widthh = document.getElementById("canvas-view").getBoundingClientRect().right - document.getElementById("canvas-view").getBoundingClientRect().left;// WIDTH: CANVAS
	heightt = document.getElementById("canvas-view").getBoundingClientRect().bottom - document.getElementById("canvas-view").getBoundingClientRect().top;  // HEIGHT: CANVAS
}
updatePosition();
// these are good for DRAGGING OPERATION and hold distances to where CANVAS is and should be
var topp2 = 0;
var leftt2 = 0;

// CANVAS listens to "move" EVENT here and finds out its coordinates relative to the CANVAS [so (0.5, 1) means 50% to the right and 100% to the bottom]
function mouseMove(event){
mousePos = { x: event.clientX, y: event.clientY };
document.getElementById("coordinates").innerHTML = "Re: " + (mousePos.x-leftt)/widthh + "   Im: " + (mousePos.y-topp)/heightt;
	if(mouseDown == true){	// has to do with dragging the CANVAS around
		drag_start(); // aactually draggs around the CANVAS
		updatePosition(); // only needs to happen after dragging not after zooming :)
	}
}
el.onmousemove = mouseMove;

//onMouseOUT the coordinates dissapear
function mout(){document.getElementById("coordinates").innerHTML = "";}
el.onmouseout = mout;

// for dragging the CANVASvar 
speedfactor = 1;// determines speed with witch the CANVAS follows the cursor.
var toppdiff = 0; // will hold the Position difference (that is to be added)
var leftdiff = 0;
let mouseDown = false; // checks if mouse is down
var initial_mousepos_x = 0; // mousepos before dragging
var initial_mousepos_y = 0;

// eventlisteners for the dragging OPERATION
el.addEventListener('mousedown', (event) => {
	mouseDown = true;
	initial_mousepos_x = mousePos.x;
	initial_mousepos_y = mousePos.y;
});
window.addEventListener('mouseup', (event) => {
  mouseDown = false;
  	topp2 += toppdiff;
	leftt2 += leftdiff;
	// uppdate global coordinates object
	coordinates.pixels(); // important beacues we dont want to mix up units now when we add stuff
	coordinates.y += toppdiff;
	coordinates.x += leftdiff;
	coordinates.uppdate();
	console.log(coordinates);
	toppdiff = 0;
	leftdiff = 0;
	calculate(); // will calculate a Image after the dragging process finished
});
// actually moving the CANVAS
function drag_start(){
	let diff_x = initial_mousepos_x-mousePos.x;
	let diff_y = initial_mousepos_y-mousePos.y;
	let newtop = (topp2 + (-diff_y/speedfactor)) + "px";
	let newlwft = (leftt2 + (-diff_x/speedfactor)) + "px";
	el.style.top = newtop;
	el.style.left = newlwft;
	toppdiff = (-diff_y/speedfactor);
	leftdiff = (-diff_x/speedfactor);
}

// these are used in zoom_start(...) and provide the theoretical distance between canvas and left/top border of screen
var canvas_HolderOffset_x = document.getElementById("cnavasHolder").getBoundingClientRect().left - document.body.getBoundingClientRect().left;
var canvas_HolderOffset_y = document.getElementById("cnavasHolder").getBoundingClientRect().top - document.body.getBoundingClientRect().top;


//now zooming the current image is handeled
function zoom_start(zooom){ // will zoom in on the picture that is currently there
	var zooom = (Math.atan(-zooom/100)+Math.PI/2)*(2/Math.PI); // this is necessary becaus zoom event returns number between [-infty, infty], and we need a factor.
	// actually zooms in on the picture [deviding by 100 to get realistic zoom speed]
	var topp3 = topp - canvas_HolderOffset_y;
	var leftt3 = leftt - canvas_HolderOffset_x;
	// x:
	el.style.width = widthh*(zooom) + "px"; 
	widthh = widthh*(zooom);
	// y:
	el.style.height = heightt*(zooom) + "px"; 
	heightt = heightt*(zooom);
	// x:
	var pointer_x = (mousePos.x - leftt3 - canvas_HolderOffset_x); // tihs is the CANVAS-MOUSE-DIFFERENCE plus the theoretical CANVAS.left
	el.style.left = (leftt3 - (pointer_x*(zooom-1))) + "px";
	leftt = leftt3 - (pointer_x*(zooom-1)) + canvas_HolderOffset_x; // uppdating global leftt var after resize
	leftt2 += - (pointer_x*(zooom-1)); // uppdating global leftt2 var after resize
	// y:
	var pointer_y = (mousePos.y - topp3 - canvas_HolderOffset_y); // tihs is the CANVAS-MOUSE-DIFFERENCE plus the theoretical CANVAS.left
	el.style.top = (topp3 - (pointer_y*(zooom-1))) + "px";
	topp = topp3 - (pointer_y*(zooom-1)) + canvas_HolderOffset_y;// uüüdating global topp var after resize
	topp2 += - (pointer_y*(zooom-1)); // uppdating global topp2 var after resize
	
	// update global coordinates object (containing zoom and translation)
	coordinates.pixels(); // important beacues we dont want to mix up units now when we add stuff
	coordinates.x += - (pointer_x*(zooom-1));
	coordinates.y += - (pointer_y*(zooom-1));
	coordinates.zoom *= zooom;
	coordinates.uppdate();
}

// GUI basically ends here and the calculation with WEB GL beginns


// coordinates holds all relevant information of the current theoretial viewport
class canvas_coordinates{	

	constructor() {
		this.x = 0;	// holds the translation Vector that points from the thoretial Right-top-Origin to the canvas-Right-Top-Origin
		this.y = 0;
		this.zoom = 1; // holds the zoom factor (relative to initial CANVAS-viewport)
		this.unit = true; // holds info about wether current numbers are in pixels or in C-coords
		this.factor = widthh/20; // holds the factor to convert from pixel to C-coordinates (widthh is CANVAS width and 20 is Real axis scale shown in beginning)
		this.yLimits = [(heightt/2)/this.factor, -(heightt/2)/this.factor]; // holds the limits of the view-port in C-coords only
		this.xLimits = [-10,10];
		this.ratio = heightt/widthh;
		this.pixelMatrix = [document.getElementById("cnavasHolder").getBoundingClientRect().right - document.getElementById("cnavasHolder").getBoundingClientRect().left,document.getElementById("cnavasHolder").getBoundingClientRect().bottom - document.getElementById("cnavasHolder").getBoundingClientRect().top] //vertical x horizontal pixel count, NOT uppdated ever...
	}
	
	pixels(){ // converts from C-field coordinates to pixel coordinates
		if(this.unit){}
		else{
			this.x = this.x*this.factor;
			this.y = this.y*this.factor;
			this.unit = false;
		}
	}
	coords(){ // converts from pixels to C-vector entries
		if(this.unit == false){}
		else{
			this.x = this.x/this.factor;
			this.y = this.y/this.factor;
			this.unit = true;
		}
	}
	
	uppdate(){ // will refresh all the properties/ recalculate with new zoom,x,y values
		if(this.unit){
			updatePosition();// just to update topp,leftt,widthh and heightt of CANVAS
			//TO BE CORECTED
			this.factor = widthh/20; 
			this.ratio = heightt/widthh;
			this.yLimits = [(this.y)/this.factor + 10*this.ratio,(this.pixelMatrix[1]-this.y)/this.factor - 10*this.ratio];
			this.xLimits = [(this.x)/this.factor + 10,(this.pixelMatrix[0]-this.x)/this.factor - 10];
			this.pixelMatrix = [document.getElementById("cnavasHolder").getBoundingClientRect().right - document.getElementById("cnavasHolder").getBoundingClientRect().left,document.getElementById("cnavasHolder").getBoundingClientRect().bottom - document.getElementById("cnavasHolder").getBoundingClientRect().top] //vertical x horizontal pixel count, NOT uppdated ever...
		}
		else{
			throw new Error('uppdating is noly supportet in pixel units');
		}
	}
	
}
const coordinates = new canvas_coordinates; // coordinates object holds all relevant info for viewport


// HERE calculations beginn
var funcc = document.getElementById("function_holder").value; // holds the information for the function that is to be plotted, changes ONCHANGE in inline JS
var MaxIterationCount = document.getElementById("iteration_holder").value; // holds the maximun iterations, changes ONCHANGE in inline JS
function calculate(){
console.log(funcc);

// the following functions either call other programms or perform natively to produce Image
//...
}


// OPEN GL HERE

const canvas = document.getElementById('canvas-view');
const gl = canvas.getContext('webgl');

if (!gl) {
    throw new Error('WebGL not supported');
}

// vertexData = [...]

// create buffer
// load vertexData into buffer

// create vertex shader
// create fragment shader
// create program
// attach shaders to program

// enable vertex attributes

// draw

var test = 1;

const vertexData = [
    0, 1, 0,
    1, -1, 0,
    -1, -1, 0,
];

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, `
attribute vec3 position;
void main() {
    gl_Position = vec4(position, 1);
}
`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, `
void main() {
    gl_FragColor = vec4(0, 0, 1, 1);
}
`);
gl.compileShader(fragmentShader);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, `position`);
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3);


</script>














<script>
//just for triggering the button on enter
// Get the input field
var input = document.getElementById("button");

// Execute a function when the user presses a key on the keyboard
input.addEventListener("keypress", function(event) {
  // If the user presses the "Enter" key on the keyboard
  if (event.key === "Enter") {
    // Cancel the default action, if needed
    event.preventDefault();
    // Trigger the button element with a click
    document.getElementById("button").click();
  }
}); 




</script>