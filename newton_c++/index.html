<!DOCTYPE html>

<head>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
<script src="math.js" type="text/javascript"></script>
</head>

<center>
	<div id="SettingsHolder">
		<h2>Function</h2>
		<center>
			<input type='text' class='setting' placeholder='input function here' id="function_holder" onchange="funcc = this.value"></input>
		</center>
		<h2>Maximun Iteration Count</h2>
		<center>
			<input type='text' class='setting' placeholder='Maximum Iteration Count here' id="iteration_holder" onchange="MaxIterationCount = this.value; console.log('MaxIterationCount changed to : ' + MaxIterationCount)"></input>
		</center>		
	</div>
	<button id="button" onclick="calculate();">
		Calculate
	</button>
</center>
<center>
	<div id="cnavasHolder">
		<canvas id="canvas-view">
		  Your browser does not seem to support HTML canvas.
		</canvas>
	</div>
</center>
<div id="coordinates">
Re: 100.3  Im: 5.1
</div>
<div class="coverUpBar" style="top:0%; height:10%; width:100%;"></div>
<div class="coverUpBar" style="left:0%; height:100%; width:5%;"></div>
<div class="coverUpBar" style="bottom:0%; height:10%; width:100%;"></div>






<style>

body {
margin:0;
padding:0;
background-color:white;
font-family: 'Roboto', sans-serif;
font-size: 1vw;
background-color:rgba(0,0,0,0.7);
overflow:hidden;
}

h2{
margin-bottom:1vh;
}


#cnavasHolder{
width:70%;
height:80%;
position:absolute;
top:10%;
left:5%;
background-color:rgba(230,230,230,0.1);
}
canvas {
  position:absolute;
  display: block;
  width: 100%;
  height: 100%;
  margin: auto;
  top:0;
  left:0;
  padding: 0;
  border: none;
  background-color: white;
  z-index:0;
}
#SettingsHolder{
width:25%;
height:80%;
position:absolute;
top:10%;
right:0%;
background-color:gray;
z-index:3;
}

button{
position:absolute;
right:2.5%;
bottom:15%;
width:20%;
background-color: #e7e7e7;
color: black;
padding: 15px 32px;
text-align: center;
text-decoration: none;
display: inline-block;
box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
transition-duration: 0.4s;
cursor:pointer;
border:0;
border-radius:10px;
font-size: 3vw;
z-index:3;
}
button:hover {
background-color: navy;
color: white;
}


input[type=text] {
  padding:10px;
  border:0;
  box-shadow:0 0 15px 4px rgba(0,0,0,0.06);
  border-radius:30px;
  width:80%;
  min-width:30%;
  text-align: center;
  margin-top:1vh;
  margin-bottom:3vh;
}

.setting{
width:80%;
}

#coordinates{
position:absolute;
background-color:rgba(10,10,10,0.3);
color:white;
height:auto;
width:auto;
bottom:10%;
right:25%;
}

.coverUpBar{
position:absolute;
z-index:3;
background-color:rgba(109,109,109,1);
}

</style>




<script>



// CANVAS listens to "zoom" EVENT here
function zoom(event){
	zoom_start(event.deltaY); // aactually draggs around the CANVAS
	calculate(); // will calculate a Image
}
const el = document.getElementById("canvas-view");
el.onwheel = zoom;


// Object holds mouse Position
let mousePos = { x: undefined, y: undefined };
// these variables hold the canvas to top/bottom/right/left DISTANCE and the canvas DIMENSIONS
var topp;
var leftt;
var widthh;
var heightt;
function updatePosition(){ // updates the position variables of the canvas
	topp = document.getElementById("canvas-view").getBoundingClientRect().top - document.body.getBoundingClientRect().top; // DISTANCE: CANVAS to WINDOW.top
	leftt = document.getElementById("canvas-view").getBoundingClientRect().left - document.body.getBoundingClientRect().left; // DISTANCE: CANVAS to WINDOW.left
	widthh = document.getElementById("canvas-view").getBoundingClientRect().right - document.getElementById("canvas-view").getBoundingClientRect().left;// WIDTH: CANVAS
	heightt = document.getElementById("canvas-view").getBoundingClientRect().bottom - document.getElementById("canvas-view").getBoundingClientRect().top;  // HEIGHT: CANVAS
}
updatePosition();
// these are good for DRAGGING OPERATION and hold distances to where CANVAS is and should be
var topp2 = 0;
var leftt2 = 0;

// CANVAS listens to "move" EVENT here and finds out its coordinates relative to the CANVAS [so (0.5, 1) means 50% to the right and 100% to the bottom]
function mouseMove(event){
mousePos = { x: event.clientX, y: event.clientY };
document.getElementById("coordinates").innerHTML = "Re: " + (mousePos.x-leftt)/widthh + "   Im: " + (mousePos.y-topp)/heightt;
	if(mouseDown == true){	// has to do with dragging the CANVAS around
		drag_start(); // aactually draggs around the CANVAS
		updatePosition(); // only needs to happen after dragging not after zooming :)
	}
}
el.onmousemove = mouseMove;

//onMouseOUT the coordinates dissapear
function mout(){document.getElementById("coordinates").innerHTML = "";}
el.onmouseout = mout;

// for dragging the CANVASvar 
speedfactor = 1;// determines speed with witch the CANVAS follows the cursor.
var toppdiff = 0; // will hold the Position difference (that is to be added)
var leftdiff = 0;
let mouseDown = false; // checks if mouse is down
var initial_mousepos_x = 0; // mousepos before dragging
var initial_mousepos_y = 0;

// eventlisteners for the dragging OPERATION
el.addEventListener('mousedown', (event) => {
	mouseDown = true;
	initial_mousepos_x = mousePos.x;
	initial_mousepos_y = mousePos.y;
});
window.addEventListener('mouseup', (event) => {
  mouseDown = false;
  	topp2 += toppdiff;
	leftt2 += leftdiff;
	// uppdate global coordinates object
	coordinates.pixels(); // important beacues we dont want to mix up units now when we add stuff
	coordinates.y += toppdiff;
	coordinates.x += leftdiff;
	coordinates.uppdate();
	console.log(coordinates);
	toppdiff = 0;
	leftdiff = 0;
	calculate(); // will calculate a Image after the dragging process finished
});
// actually moving the CANVAS
function drag_start(){
	let diff_x = initial_mousepos_x-mousePos.x;
	let diff_y = initial_mousepos_y-mousePos.y;
	let newtop = (topp2 + (-diff_y/speedfactor)) + "px";
	let newlwft = (leftt2 + (-diff_x/speedfactor)) + "px";
	el.style.top = newtop;
	el.style.left = newlwft;
	toppdiff = (-diff_y/speedfactor);
	leftdiff = (-diff_x/speedfactor);
}

// these are used in zoom_start(...) and provide the theoretical distance between canvas and left/top border of screen
var canvas_HolderOffset_x = document.getElementById("cnavasHolder").getBoundingClientRect().left - document.body.getBoundingClientRect().left;
var canvas_HolderOffset_y = document.getElementById("cnavasHolder").getBoundingClientRect().top - document.body.getBoundingClientRect().top;


//now zooming the current image is handeled
function zoom_start(zooom){ // will zoom in on the picture that is currently there
	var zooom = (Math.atan(-zooom/100)+Math.PI/2)*(2/Math.PI); // this is necessary becaus zoom event returns number between [-infty, infty], and we need a factor.
	// actually zooms in on the picture [deviding by 100 to get realistic zoom speed]
	var topp3 = topp - canvas_HolderOffset_y;
	var leftt3 = leftt - canvas_HolderOffset_x;
	// x:
	el.style.width = widthh*(zooom) + "px"; 
	widthh = widthh*(zooom);
	// y:
	el.style.height = heightt*(zooom) + "px"; 
	heightt = heightt*(zooom);
	// x:
	var pointer_x = (mousePos.x - leftt3 - canvas_HolderOffset_x); // tihs is the CANVAS-MOUSE-DIFFERENCE plus the theoretical CANVAS.left
	el.style.left = (leftt3 - (pointer_x*(zooom-1))) + "px";
	leftt = leftt3 - (pointer_x*(zooom-1)) + canvas_HolderOffset_x; // uppdating global leftt var after resize
	leftt2 += - (pointer_x*(zooom-1)); // uppdating global leftt2 var after resize
	// y:
	var pointer_y = (mousePos.y - topp3 - canvas_HolderOffset_y); // tihs is the CANVAS-MOUSE-DIFFERENCE plus the theoretical CANVAS.left
	el.style.top = (topp3 - (pointer_y*(zooom-1))) + "px";
	topp = topp3 - (pointer_y*(zooom-1)) + canvas_HolderOffset_y;// uüüdating global topp var after resize
	topp2 += - (pointer_y*(zooom-1)); // uppdating global topp2 var after resize
	
	// update global coordinates object (containing zoom and translation)
	coordinates.pixels(); // important beacues we dont want to mix up units now when we add stuff
	coordinates.x += - (pointer_x*(zooom-1));
	coordinates.y += - (pointer_y*(zooom-1));
	coordinates.zoom *= zooom;
	coordinates.uppdate();
}

// GUI basically ends here and the calculation with WEB GL beginns


// coordinates holds all relevant information of the current theoretial viewport
class canvas_coordinates{	

	constructor() {
		this.x = 0;	// holds the translation Vector that points from the thoretial Right-top-Origin to the canvas-Right-Top-Origin
		this.y = 0;
		this.zoom = 1; // holds the zoom factor (relative to initial CANVAS-viewport)
		this.unit = true; // holds info about wether current numbers are in pixels or in C-coords
		this.factor = widthh/20; // holds the factor to convert from pixel to C-coordinates (widthh is CANVAS width and 20 is Real axis scale shown in beginning)
		this.yLimits = [(heightt/2)/this.factor, -(heightt/2)/this.factor]; // holds the limits of the view-port in C-coords only
		this.xLimits = [-10,10];
		this.ratio = heightt/widthh;
		this.pixelMatrix = [document.getElementById("cnavasHolder").getBoundingClientRect().right - document.getElementById("cnavasHolder").getBoundingClientRect().left,document.getElementById("cnavasHolder").getBoundingClientRect().bottom - document.getElementById("cnavasHolder").getBoundingClientRect().top] //vertical x horizontal pixel count, NOT uppdated ever...
	}
	
	pixels(){ // converts from C-field coordinates to pixel coordinates
		if(this.unit){}
		else{
			this.x = this.x*this.factor;
			this.y = this.y*this.factor;
			this.unit = false;
		}
	}
	coords(){ // converts from pixels to C-vector entries
		if(this.unit == false){}
		else{
			this.x = this.x/this.factor;
			this.y = this.y/this.factor;
			this.unit = true;
		}
	}
	
	uppdate(){ // will refresh all the properties/ recalculate with new zoom,x,y values
		if(this.unit){
			updatePosition();// just to update topp,leftt,widthh and heightt of CANVAS
			//TO BE CORECTED
			this.factor = widthh/20; 
			this.ratio = heightt/widthh;
			this.yLimits = [(this.y)/this.factor + 10*this.ratio,(this.pixelMatrix[1]-this.y)/this.factor - 10*this.ratio];
			this.xLimits = [(this.x)/this.factor + 10,(this.pixelMatrix[0]-this.x)/this.factor - 10];
			this.pixelMatrix = [document.getElementById("cnavasHolder").getBoundingClientRect().right - document.getElementById("cnavasHolder").getBoundingClientRect().left,document.getElementById("cnavasHolder").getBoundingClientRect().bottom - document.getElementById("cnavasHolder").getBoundingClientRect().top] //vertical x horizontal pixel count, NOT uppdated ever...
		}
		else{
			throw new Error('uppdating is noly supportet in pixel units');
		}
	}
	
}
const coordinates = new canvas_coordinates; // coordinates object holds all relevant info for viewport


// HERE calculations beginn
var funcc = document.getElementById("function_holder").value; // holds the information for the function that is to be plotted, changes ONCHANGE in inline JS
var MaxIterationCount = document.getElementById("iteration_holder").value; // holds the maximun iterations, changes ONCHANGE in inline JS
function calculate(){
	//console.log(calculatePreset(funcc));// can only calculate functions of type x^n-1
	runGL();
// the following functions either call other programms or perform natively to produce Image
//...
}

function calculatePreset(string){ // uses binomial theorem to calculate re and Im of f/f' of x^n-1
	var n = string.substring(string.indexOf('^') + 1, string.indexOf('-')); // gets the power
		// extracts real and im part
		var real_part = "";
		var im_part = "";
		var u_a	= "";
		var u_b = "";
		var v_a = "";
		var v_b = "";
		for (var k = 0; k < n; k++){
			if(k%4 == 0){ // i^4 = 1
				real_part += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					u_a += String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					u_b += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
			else if(k%3 == 0){ // i^3 = -i
				im_part += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					v_a += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					v_b += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
			else if(k%2 == 0){ // i^2 = -1
				real_part += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					u_a += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					u_b += "-" + String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
			else{ // i^1 = i
				im_part += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k) + ".0)";
				if((n-k) != 0){
					v_a += String(binomial(n,k)) + ".0*pow(a," + (n-k-1) + ".0)*pow(b," + String(k) + ".0)*" + String(n-k) + ".0";
				}
				if(k != 0){
					v_b += String(binomial(n,k)) + ".0*pow(a," + (n-k) + ".0)*pow(b," + String(k-1) + ".0)*" + String(k) + ".0";
				}
			}
	
	}
	var u = real_part;
	var v = im_part;
	var final_real = "(1.0/(pow(" + u_a + ",2.0) + pow(" + v_a + ",2.0)))*(" + u + "*" + u_a + " + " + v + "*" + v_a + ")";
	var final_im = "(1.0/(pow(" + u_a + ",2.0) + pow(" + v_a + ",2.0)))*(" + u + "*" + u_b + " + " + v + "*" + v_b + ")";
	
	return [final_real, final_im];// reference wikipedia : https://de.wikipedia.org/wiki/Newtonverfahren
}




// OPEN GL HERE
function runGL(){
var Schranke = 0.0001 // einfac setzen (empirische Entscheidung)

// this holds the NEWTON Algorithm
var functionString = [
"float temp_real = position[0];",
"float temp_im = position[1];",
"int counter = 1;",
"int Booler = 1;",
"for (int j = 0; j < " + MaxIterationCount + "; j += 1){",
	//"if(Booler == 1 && j == 1 && (pow(2.0,3.0) < 1000.0)){", // line is purely for testing
	"if(Booler == 1 && pow(pow("  + calculatePreset(funcc)[0].replaceAll('a', 'temp_real').replaceAll('b', 'temp_im') + ",2.0) + pow(" + calculatePreset(funcc)[1].replaceAll('b', 'temp_im').replaceAll('a', 'temp_real') + ",2.0),0.5) < " + Schranke + "){",
		"counter = j;",
		"Booler = 2;",
	"}",
	"temp_real -= " + calculatePreset(funcc)[0].replaceAll('a', 'temp_real').replaceAll('b', 'temp_im') + ";",
	"temp_im -= " + calculatePreset(funcc)[1].replaceAll('b', 'temp_im').replaceAll('a', 'temp_real') + ";",
"}",
"float tester = " + calculatePreset(funcc)[0].replaceAll('a', 'temp_real').replaceAll('b', 'temp_im') + ";",
"vColor = vec3((tester),atan(float(counter))/6.28 + 0.5,0.5);"
].join("\n")

//console.log(functionString);

//GET canvas elem
const canvas = el;
const gl = canvas.getContext('webgl');

// cheacks if browser supports WEBGL
if (!gl) {
    throw new Error('WEBGL is not supported on your BROWSER');
}

// clears the background color
gl.clearColor(0,0,1,1);
gl.clear(gl.COLOR_BUFFER_BIT);


const positionBuffer = gl.createBuffer(); // create BUFFER for position verteces
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.DYNAMIC_DRAW);



const vertexShader = gl.createShader(gl.VERTEX_SHADER); // create actual shader
gl.shaderSource(vertexShader, [
"precision highp float;",
"attribute vec3 position;",
"varying vec3 vColor;",
"void main() {",// position vertecies get placed
    "gl_Position = vec4(position, 1);",// for loop has to take place here NEWTON INTEROPLATION
	functionString,
	"}"
].join("\n"));
gl.compileShader(vertexShader);//compile vertexShader

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);// create fragment shader
gl.shaderSource(fragmentShader, `
precision mediump float;

varying vec3 vColor; // will pass information from position to color main-function

void main() { // color is beeing assigned (by position reference)
    gl_FragColor = vec4(vColor, 1);
}
`);
gl.compileShader(fragmentShader); // compile fragmentShader


const program = gl.createProgram();// creating program for shaders here
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);

gl.linkProgram(program);// linking

const positionLocation = gl.getAttribLocation(program, `position`);// attribute assigning ; position
gl.enableVertexAttribArray(positionLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);


gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, vertexData.length/3); // actually drawing here
}
























//just for triggering the button on enter
// Get the input field
var input = document.getElementById("button");

// Execute a function when the user presses a key on the keyboard
input.addEventListener("keypress", function(event) {
  // If the user presses the "Enter" key on the keyboard
  if (event.key === "Enter") {
    // Cancel the default action, if needed
    event.preventDefault();
    // Trigger the button element with a click
    document.getElementById("button").click();
  }
}); 


function binomial(n, k) { // just binomial coefficient calc
     if ((typeof n !== 'number') || (typeof k !== 'number')){
		n = parseInt(n);
		k = parseInt(k);
	 }
    var coeff = 1;
    for (var x = n-k+1; x <= n; x++) coeff *= x;
    for (x = 1; x <= k; x++) coeff /= x;
    return Math.round(coeff);
}


const vertexData = [ // JUST DATA (many more vertecies are needed to ensure clear image)

];
// load vertecies
var ammounOfVerteciesX = 1000;
var ammounOfVerteciesY = 1000;
for(jk = 0; jk < ammounOfVerteciesY; jk++){
	for(kj = 0; kj < ammounOfVerteciesX; kj++){
		vertexData.push(-1 + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY) + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY)*jk,0);
		vertexData.push(-1 + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY) + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY)*jk,0,-1 + (2/ammounOfVerteciesX) + (2/ammounOfVerteciesX)*kj,-1 + (2/ammounOfVerteciesY)*jk,0);
	}
}

</script>